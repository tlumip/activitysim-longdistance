# ActivitySim
# See full license in LICENSE.txt

import logging

import numpy as np
import pandas as pd
from activitysim.core import workflow

from .ldt_pattern import LDT_PATTERN

logger = logging.getLogger(__name__)


@workflow.step
def ldt_create_longdist_trips(
    state: workflow.State,
    longdist_tours: pd.DataFrame,
    persons_merged: pd.DataFrame,
):
    """
    This method processes the longdist_tours dataframe after the tour generation and pattern assignment steps
    and creates a longdist_trips dataframe, an individual-level record of all trips (both outgoing and return)
    that have been generated by ActivitySim.

    Requires an ldt_pattern, tour_type_count, tour_type_num, tour_num, tour_count, internal_destination, external_destination, actor_type
    external_tour_mode, tour_mode, origin, household_id, number_of_participants, and person_id fields, all of which are already
    present/created during model execution.
    """
    # list to store all the new trip rows
    new_rows = []
    # drop columns that shouldn't be in the trips df
    res = (
        longdist_tours.copy()
        .reset_index()
        .drop(["tour_type_count", "tour_type_num", "tour_num", "tour_count"], axis=1)
    )

    logger.info("Creating hte longdist_trips csv")

    # create broad trip purpose -- travel out or travel home
    res["purpose"] = np.where(
        ((res["ldt_pattern"] & 3) == LDT_PATTERN.BEGIN)
        | ((res["ldt_pattern"] & 3) == LDT_PATTERN.COMPLETE),
        "travel_out",
        "",
    )
    res["purpose"] = np.where(
        (res["ldt_pattern"] & 3) == LDT_PATTERN.END, "travel_home", res["purpose"]
    )

    res["destination"] = np.where(
        res["internal_destination"] != -1,
        res["internal_destination"],
        res["external_destchoice"],
    )
    res["mode_choice"] = np.where(
        res["external_tour_mode"] != -1, res["external_tour_mode"], res["tour_mode"]
    )

    # create logical destinations and origins that accurately describes a trip
    # e.g., for end trips, the destination would be a home_zone and the origin would
    # be the ldt trip location a person is currently in
    temp = res["origin"].copy()
    res["origin"] = np.where(
        (res["ldt_pattern"] & 3) == LDT_PATTERN.END, res["destination"], res["origin"]
    )
    res["destination"] = np.where(
        (res["ldt_pattern"] & 3) == LDT_PATTERN.END, temp, res["destination"]
    )

    for _, row in res[(res["ldt_pattern"] & 3) == LDT_PATTERN.COMPLETE].iterrows():
        new_row = row.copy()
        temp = new_row["destination"]
        new_row["destination"] = new_row["origin"]
        new_row["origin"] = temp
        new_row["purpose"] = "travel_home"
        new_rows.append(pd.DataFrame(new_row).T)
    # add the copied tours array that was created earlier
    new_rows.append(res)
    res = pd.concat(new_rows)

    households = res[res["actor_type"] == "household"]
    res = res[res["actor_type"] != "household"]

    household_to_persons = (
        persons_merged[["household_id"]].reset_index().set_index("household_id")
    )
    new_rows = []
    for _, row in households.iterrows():
        id = row["household_id"]
        persons_in_hh = household_to_persons.loc[id, "person_id"]
        if np.isscalar(persons_in_hh):
            new_rows.append(pd.DataFrame(row).T)
            continue
        for person in household_to_persons.loc[id, "person_id"]:
            new_row = row.copy()
            new_row["person_id"] = person
            new_rows.append(pd.DataFrame(new_row).T)
    new_rows.append(res)

    res = pd.concat(new_rows).reset_index().drop("index", axis=1).reset_index()

    res["mode_choice"] = np.where(
        res["actor_type"] == "household",
        res["mode_choice"] + res["number_of_participants"].astype(str),
        res["mode_choice"],
    )

    # convert longdist_tours csv into a longdist_trips csv
    state.add_table("longdist_trips", res)
